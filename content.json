{"meta":{"title":"二层楼","subtitle":null,"description":null,"author":null,"url":"http://iaminvoker.com"},"pages":[{"title":"tags","date":"2018-12-16T11:30:50.000Z","updated":"2018-12-16T11:33:48.314Z","comments":true,"path":"tags/index.html","permalink":"http://iaminvoker.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"history对象","slug":"2018-02-09-history对象","date":"2018-02-09T06:09:43.000Z","updated":"2018-12-17T11:07:36.726Z","comments":true,"path":"2018/02/09/2018-02-09-history对象/","link":"","permalink":"http://iaminvoker.com/2018/02/09/2018-02-09-history对象/","excerpt":"","text":"概述浏览器窗口的 history 对象保存了当前窗口的浏览历史记录，如果当前窗口先后访问了三个网址，则history.length=3.history 对象的方法： back()：移动到上一个访问页面，等同于浏览器的后退键。 forward()：移动到下一个访问页面，等同于浏览器的前进键 go()：接受一个整数作为参数，移动到该整数指定的页面，比如 go(1)相当于 forward()，go(-1)相当于 back()。 如果移动的范围超过了边界，并不会报错，而是默认失败返回上一页一般是从缓存中读取，而不是从服务器重新拉取 history.pushState()history.pushState()接受三个参数：state：一个与指定网址相关的状态对象，popstate 事件触发时，该对象会传入回调函数。如果不需要这个对象，此处可以填 null。title：新页面的标题，但是所有浏览器目前都忽略这个值，因此这里可以填 null。url：新的网址，必须与当前页面处在同一个域。浏览器的地址栏将显示这个网址。如果地址跨域，则会报错例如： 123//加入当前网址为test.com/a.html,使用pushState加入一个新的记录history.pushState(&#123;state:test&#125;,'page b','b.html )//添加这条记录后，浏览器地址栏立即显示test.com/b.html,但并不会跳转到b.html ，也不会检测b.html是否存在，它只是会成为最新的一条浏览历史记录。此时，当再次输入一个新的访问地址后，点击后退按钮，页面地址栏将显示b.html，再次点击后退按钮，地址栏显示a.html history.replaceState()history.replaceState 的参数和 pushState 的参数一样，只不过这个方法是替换当前修改当前记录 12345//假如当前网址为test.com/a.htmlhistory.pushState(null, null, \"a.html\");history.pushState(null, null, \"b.html\");history.replaceState(null, null, \"c.html\");//此时,点击后退按钮，显示test.com/a.html,顾名思义,replaceState会替换(删除)掉当前的记录 popstate 事件当浏览记录发生变化的时候，会触发 popState 事件，但是 pushState 和 replaceState 无法触发这个事件，只有调用 back,forward,go 方法或者点击前进后退才会触发这个事件，这个事件的事件对象的 state 属性指向 pushState 和 replaceState 指定的 state 对象，不过 state 对象也可以直接通过 history.state 获取","categories":[{"name":"前端","slug":"前端","permalink":"http://iaminvoker.com/categories/前端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://iaminvoker.com/tags/前端/"}]},{"title":"React生命周期","slug":"2018-02-09-React生命周期","date":"2018-02-09T06:08:43.000Z","updated":"2018-12-17T11:06:43.222Z","comments":true,"path":"2018/02/09/2018-02-09-React生命周期/","link":"","permalink":"http://iaminvoker.com/2018/02/09/2018-02-09-React生命周期/","excerpt":"","text":"React Component 组件具有生命周期，一般来说，React 组件的生命周期分为四种状态： Initialization：初始化 Mounting：已插入真实 DOM， Updation：正在重新渲染， Unmounting：已移除真实 DOM React 在这些生命周期内提供了一系列钩子函数： 1. Initialization在这个阶段，我们可以设置初始化的状态和属性，或者我们也可以设置属性默认值 1234567891011class ContraMusicPlayer extends React.Componentconstructor(props) &#123; super(props); this.state = &#123; volume: 70, status: 'pause' &#125;&#125;ContraMusicPlayer.defaultProps = &#123; theme: 'dark'&#125;; 一般我们在构造函数里设置初始化状态，并在稍后使用setState去改变状态 2.Mounting在经历过初始化阶段后，React 组件已经开始准备将组件渲染进真实 dom 中去，此时需要提供渲染前后的钩子函数。 componentWillMount这个钩子函数将在组件渲染进真实 dom 之前调用，在这个函数之后，组件将被渲染进真实 dom，所有在渲染之前的操作都要在这里执行。这个函数在初次渲染之前只会调用一次。可以再这里调用 setState，而且不会触发重绘 render将组件渲染至浏览器中，这个函数是个纯函数，就是说在某个时刻相同的输入必将得到相同的输出 componentDidMount这个钩子函数将在组件被渲染进 dom 之后调用，在这个函数里我们可以访问到真实渲染出的 dom 元素，这也就意味着我们可以在这里使用 jquery 等库去访问真实 dom。可以再这里调用 setState，会触发重绘 3.Updation这个阶段，组件已经渲染进了浏览器，但从两处得到更新：传递新的 props 或者更新了新的状态 componentWillReceiveProps(nextProps)这个函数在属性被改变后调用(不包含初次渲染)这里可以调用 setState shouldComponentUpdate(nextProps,nextState) 这个函数在属性或状态更新后将告诉 React 是否要去重新渲染，这个函数默认返回 true，也就是需要重新渲染。这个函数一般用于需要我们手动控制 React 的渲染以提升性能时使用。 componentWillUpdate这个函数将在 shouldComponentUpdate 返回 true 时调用，一般我们需要在更新前做一些计算操作时使用这个函数。这里不能调用 setState render渲染 componentDidUpdate这个函数在 React 已经更新了 dom 后调用，一般用于重新绑定第三方库，从而让这些库更新自己。这里可以调用 setState 4. Unmounting componentWillUnmount这个函数是生命周期的最后一个钩子，它在组件被从 dom 中移除时调用，在这里我们可以做一些清理工作。这里不能调用 setState。 关于组件详细的过程可以参考React 生命周期","categories":[{"name":"React","slug":"React","permalink":"http://iaminvoker.com/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://iaminvoker.com/tags/React/"}]},{"title":"React基础","slug":"2018-02-09-React基础","date":"2018-02-09T06:06:11.000Z","updated":"2018-12-17T11:09:45.478Z","comments":true,"path":"2018/02/09/2018-02-09-React基础/","link":"","permalink":"http://iaminvoker.com/2018/02/09/2018-02-09-React基础/","excerpt":"","text":"1. 对 React 的简单认识 React 是一种构建 UI 的框架 React 专注于视图(V) React 是通过细化的组件构成复杂 UI 的 2.划重点 jsx，就是一种 JavaScript(xml)的扩展语法，简单的说就是在 JavaScript 中用 xml 语法定义 dom 结构和行为 123456789101112131415//简单的jsx语法const element = &lt;h1&gt;Hello, world!&lt;/h1&gt;;//jsx就是表达式const name = \"world\";const element = &lt;h1&gt;hello,&#123;name&#125;&lt;/h1&gt;;//jsx的对象表示const element = &lt;h1 className=\"greeting\"&gt;Hello, world!&lt;/h1&gt;;//这段jsx的对象表示为const element = &#123; type: \"h1\", props: &#123; className: \"greeting\", children: \"Hello, world\", &#125;,&#125;; 要使用 jsx 需要使用 Babel 编译，推荐使用 ES6+webpack+babel 的开发方式 render,将 React DOM 渲染到根元素上 12const element = &lt;h1&gt;Hello, world&lt;/h1&gt;;ReactDOM.render(element, document.getElementById(\"root\")); 根元素将作为 React 生成的 DOM 元素的父元素，根元素是一个原生 dom 元素 component 和 props component,组件，是 React 里最重要最基本的东西 Components let you split the UI into independent, reusable pieces, and think about each piece in isolation.(组件可以让你将 UI 分离为独立的可复用的片段，然后独立的去考虑这些片段) 组件分为两种： 1.Functional Components,函数组件 123function Welcome(props) &#123; return &lt;h1&gt;Hello, &#123;props.name&#125;&lt;/h1&gt;;&#125; 2.Class Components， 类组件 12345class Welcome extends React.Component &#123; render() &#123; return &lt;h1&gt;Hello, &#123;this.props.name&#125;&lt;/h1&gt;; &#125;&#125; 组件也可以组合为复合组件 12345678910111213function Welcome(props) &#123; return &lt;h1&gt;Hello, &#123;props.name&#125;&lt;/h1&gt;;&#125;function App() &#123; return ( &lt;div&gt; &lt;Welcome name=\"Sara\" /&gt; &lt;Welcome name=\"Cahal\" /&gt; &lt;Welcome name=\"Edite\" /&gt; &lt;/div&gt; );&#125; 组件的名字必须大写，否则 React 无法识别，而真正的 dom 元素需要小写 props,属性，个人理解就是描述这个 React 组件的初始化的“形状”并定义它的行为，props 一般作为初始化参数，或者状态提升传递函数。在 React 中，有一条严格的规则，就是所有的 React 组件相对他们的 props 来说必须是 pure function(纯函数)，大概意思就是 React 组件的输出只能由他们的 props(当然还有 state)决定，而不依赖于外界props 是只读的，一旦赋值后就无法改变它的值 State 和 Lifecycle,状态和生命周期(大佬登场) State,状态有这么一个需求，需要在页面显示实时的时间，假如正在使用 jQuery，一般的做法就是，获取需要显示时间的 dom 元素，每秒去获取当前时间，并替换这个元素的文本内容。React 的做法是，给这个显示时间的组件一个状态，并将这个状态赋给需要显示的文本内容，然后每秒去更新这个状态，此时 React 会自动更新 UI，这样做的好处就是无需关注如何获取元素，如何绑定内容（说实话，这些东西算是前端开发里面最无聊最浪费时间的东西了），我们关注的重点就是如何去改变这个状态这种核心业务逻辑了。这些东西看似差别不大，但当业务场景比较复杂， dom 更新频繁的时候，各种获取 dom 元素赋值的操作让人头皮发麻这里需要注意的是，在操作 dom 元素的时候，我们一般是通过 domAPI 获取元素，并操作更新他们，在这个过程中，代价是很昂贵的，而单纯的 js 执行性能是优于 dom 操作的，因此 React 采取了一种叫做虚拟 dom(v-dom)的东西，将 dom 树抽象为一种对象表示，每次更新状态时，React 都会采用 diff 算法比较，得出需要更新的最小 dom，然后再去重新渲染这部分，这样就将 dom 更新渲染的代价降到最低。(这种说法的前提是我们没有手动的去为原生操作做优化，在我们手动做优化的前提下，任何框架的性能都不会高于原生操作。然而，使用框架可以保证牺牲最小的性能代价去获得代码的可维护性，提高开发效率，解放劳动力，何乐而不为。参考)。举个栗子 123456789101112131415161718//给这个显示时间的组件一个date状态，但此时这个状态并没有更新class Clock extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; date: new Date() &#125;; &#125; render() &#123; return ( &lt;div&gt; &lt;h1&gt;Hello, world!&lt;/h1&gt; &lt;h2&gt;It is &#123;this.state.date.toLocaleTimeString()&#125;.&lt;/h2&gt; &lt;/div&gt; ); &#125;&#125;ReactDOM.render(&lt;Clock /&gt;, document.getElementById(\"root\")); LifeCycle，生命周期在这个组件中，要更新显示的时间，需要在这个组件已经插入文档后再去改变(想想学 js 最开始容易犯的毛病就是在 dom 元素还没有创建和插入时就去获取这个元素，然后就是 undefined…)生命周期是 React 内部定义的一系列函数，这些函数称为”lifecycle hooks”,”生命周期钩子”，通过这些钩子，就可以在组件装载后后改变状态或者组件卸载后释放资源 12345678910111213141516171819202122232425262728293031class Clock extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; date: new Date() &#125;; &#125; //组件装载钩子 componentDidMount() &#123; //改变状态 this.timerID = setInterval(() =&gt; this.tick(), 1000); &#125; //组件卸载钩子 componentWillUnmount() &#123; clearInterval(this.timerID); &#125; tick() &#123; this.setState(&#123; date: new Date(), &#125;); &#125; render() &#123; return ( &lt;div&gt; &lt;h1&gt;Hello, world!&lt;/h1&gt; &lt;h2&gt;It is &#123;this.state.date.toLocaleTimeString()&#125;.&lt;/h2&gt; &lt;/div&gt; ); &#125;&#125;ReactDOM.render(&lt;Clock /&gt;, document.getElementById(\"root\")); 使用状态时需要注意一些问题： 不要直接改变 state 的值，而是使用 setState() 这个值的改变是异步的 React 会合并状态的改变 Data Flows Down数据流React 的数据流是单向的，也就是说任何数据(状态)的改变只会影响组件树中位于该组件之下的组件 事件处理React 的事件处理非常类似于 DOM0 级事件，也就是在元素上直接绑定事件，但是有两点不同： 命名使用camelCase命名，比如onClick 事件处理需要传递一个函数而不是字符串 举个栗子 123456789101112function ActionLink() &#123; function handleClick(e) &#123; e.preventDefault(); console.log(\"The link was clicked.\"); &#125; return ( &lt;a href=\"#\" onClick=&#123;handleClick&#125;&gt; Click me &lt;/a&gt; );&#125; 在 React 中，React 根据 W3C 的标准重新定义了 Event 事件，所以它的 Event 不存在兼容性问题需要注意的问题：如果使用 ES6 class 的形式，事件处理函数的 this 需要格外注意 状态提升假如现在有多个组件，它们需要对某个状态做出相同的响应，可以将这种状态提升至离这些组件最近的某个父组件。这个概念看起来很高大上，但个人理解为就是某个子组件需要一个改变状态后的处理函数，这个处理函数其实可以使用父组件通过 props 传递来的函数，那么这个子组件的状态处理就被提升或者说代理到了父组件上 以上只是刚接触 React 的个人理解，如果错了，那就错了吧。。","categories":[{"name":"React","slug":"React","permalink":"http://iaminvoker.com/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://iaminvoker.com/tags/React/"}]},{"title":"Event Loop","slug":"2018-02-09-Event-Loop","date":"2018-02-09T05:38:08.000Z","updated":"2018-12-17T11:02:19.804Z","comments":true,"path":"2018/02/09/2018-02-09-Event-Loop/","link":"","permalink":"http://iaminvoker.com/2018/02/09/2018-02-09-Event-Loop/","excerpt":"","text":"[TOC] 一个问题123456789console.log(1);setTimeout(function() &#123; console.log(2);&#125;, 1000);new Promise(function(resolve) &#123; console.log(3); resolve();&#125;).then(console.log(4));console.log(5); 这段代码的正确输出应该是：1 3 5 4 2，为啥呢？ 我们知道 JavaScript 是单线程的，这对于同步代码还好，但对于异步阻塞代码，如果依然”一行一行执行”，就会阻塞主线程。为了避免主线程被阻塞，使用了 Event Loop 方案，事件循环。 根据 HTML 的规范，Event Loop 的大概过程是： 执行最旧的 task（一次） 检查是否存在 microtask，然后不停执行，直到清空队列（多次） 执行 render task 和 microtask 是两个异步任务的分类，不同的异步任务会被分配到不同的任务队列，然后等待 Event Loop 将它们压入执行栈执行。 task 主要包含：包括整体代码，setTimeout, setInterval,I/O,UI 交互，setImmediate, microtask 主要包含： Promise，process.nextTick(node 环境)、MutaionObserver 最基本的事件循环就是： 同步和异步任务分别进入不同的执行”场所”，同步的进入主线程，异步的进入 Event Table 并注册函数。 当指定的事情完成时，Event Table 会将这个函数移入 Event Queue。 主线程内的任务执行完毕为空，会去 Event Queue 读取对应的函数，进入主线程执行。 上述过程会不断重复。 明白了 Event Loop 的大致流程，就能就是上面的代码了： 整段代码进入主线程，先执行 log(1)，输出 1， 2) 遇到 setTimeout，将其回调函数注册后分发给 task Event Quene,3) 遇到 promise，new Promise 立即执行，执行 log(3),输出 3，then 函数注册进入 microtask Event Quene，4) 执行 log(5)，输出 55) 至此整体代码作为第一个 task 执行完毕，然后去看 microtask，在 microtask Event Quene 中有一个 then 任务，将其压入执行栈，执行 log(4),输出 46) 第一轮事件循环结束，开始第二轮循环，仍然先从 task 开始，发现 task Event Quene 有一个 setTimeout 注册的回调，立即执行 log(2)，输出 27) 最后的结果就是 1 3 5 4 2","categories":[{"name":"JavaScript深入系列","slug":"JavaScript深入系列","permalink":"http://iaminvoker.com/categories/JavaScript深入系列/"}],"tags":[{"name":"JavaScript深入系列","slug":"JavaScript深入系列","permalink":"http://iaminvoker.com/tags/JavaScript深入系列/"}]},{"title":"理解对象","slug":"2018-02-09-理解对象","date":"2018-02-09T05:37:08.000Z","updated":"2018-05-03T09:32:23.664Z","comments":true,"path":"2018/02/09/2018-02-09-理解对象/","link":"","permalink":"http://iaminvoker.com/2018/02/09/2018-02-09-理解对象/","excerpt":"","text":"[TOC] 对象的定义对象是一个无序属性的集合，这些属性可以包括基本值、对象或者函数 对象的属性数据属性数据属性是一个包含数据值的属性，可以对这个属性进行读写。数据属性有4个描述其行为地特性。 [[Configurable]]:可配置性，它表示这个属性是否可以通过delete删除，是否可以修改属性特性，是否可以修改为访问器属性。使用对象字面量定义的属性这个值默认为true。 [[Enumerable]]:可枚举性，它表示这个属性是否可以被for-in 遍历出来。使用对象字面量定义的属性这个值默认为true。 [[Writable]]:可写性，它表示这个属性的值是否可以被修改。使用对象字面量定义的属性这个值默认为true。 [[Value]]:值，它包含这个属性的数据值，读取这个属性时从这里读，写入属性值的时候把新值保存在这里，这个特性默认值为undefined。 想要修改这些属性的特性，需要使用Object.defineProperty() 方法，这个方法接受三个参数，要修改的属性所在的对象，要修改的属性名，一个对象描述符。 将属性修改为不可写后，在非严格模式下，赋值操作被忽略了，但在严格模式下，将抛出错误。 将属性修改为不可配置后，就无法修改除了writable以外的特性。 1234567891011121314151617181920const obj =&#123; name:'ojbk', age:24&#125;;Object.defineProperty(obj,'age',&#123; writable:false&#125;);obj.age = 25;console.log(obj.age);//24Object.defineProperty(obj,'name',&#123;configurable:false&#125;);delete obj.name;//什么也不会发生console.log(obj.name);//'ojbk'Object.defineProperty(obj,'name',&#123;enumerable:true&#125;);//err 访问器属性访问器属性不包含值属性，它包含了一对getter和setter函数，在读取访问器属性时，会调用getter函数，在写入访问器属性时，会调用setter函数。访问器属性也包含了4个特性： [[Configurable]]:可配置性，它表示这个属性是否可以通过delete删除，是否可以修改属性特性，是否可以修改为数据属性。使用对象字面量定义的属性这个值默认为true。 [[Enumerable]]:可枚举性，它表示这个属性是否可以被for-in 遍历出来。使用对象字面量定义的属性这个值默认为true。 [[Get]]:在读取属性值时调用的函数，默认为undefined。 [[Set]]:在写入属性值时调用的函数，默认为undefined。 不一定需要同时定义[[Get]]和[[Set]]，只定义了[[Get]]意味着这个属性是只读的，在严格模式下尝试写入会跑出错误，同理，只定义[[Set]]表明这个属性是只写的。 同时设置多个属性Object.defineProperties()，这个方法接受两个参数，需要设置属性的对象和属性描述符。 获取属性描述符Object.getOwnPropertyDescriptor(),这个方法接受两个参数，属性所在的对象和需要获取描述符的属性 创建对象简单创建创建一个简单对象一般有三种方法： 通过new创建 1const obj = new Object() 对象字面量(最常用) 1const obj = &#123;&#125;; Object.create() 12const obj = Object.create(&#123;a:1&#125;);console.log(obj.a);//a 这个方法接受两个参数，第一个是这个新对象的原型，第二个属性用来描述对象的属性。如果给这个函数传递null作为第一个参数，那么新建的对象将不会继承任何东西，比如基础方法。如果给这个函数传递Object.prototype作为第一个参数，那它就和使用new或者对象字面量创建的对象一样。这是一个强大的方法，通过他可以实现继承。 模式创建 工厂模式 1234567891011function personFactory(name,age)&#123; const o = &#123;&#125;; o.name = name; o.age = age; o.sayName = function() &#123; console.log(this.name) &#125;; return o;&#125;;const obj = personFactory('ojbk',24);obj.sayName();//'ojbk' 这个模式解决了创建相似对象的问题，但这样创建的对象无法识别(不知道这个对象到底是谁创建的)。 构造函数模式 123456789101112function Person(name,age)&#123; this.name = name; this.age = age; this.sayName = function()&#123; console.log(this.name) &#125;&#125;;const p1 = new Person('ok',12);p1.sayName();//'ojbk'const p2 = new Person('ojbk',24);p2.sayName();//'ojbk' 在创建实例的时候，使用new操作符，这种方式调用构造函数经历4个步骤： 创建一个新对象； 将构造函数的作用域赋给新对象(指定this) 执行构造函数中的代码(给新对象添加属性) 返回这个新对象 这样创建的对象就可以判断到底是谁创建了它们。 12p1.constructor === Person;//truep1.instanceof Person;//true 使用这种方法有一个问题就是会在每个实例上都会重新创建每个方法，但是，一个函数如果是完成相同功能 那么重复创建是没有必要的。 原型模式 函数拥有一个prototype属性，这个属性指向一个对象，这个对象可以包含实例可以共享的所有属性和方法。 123456789function Person()&#123;&#125;Person.prototype.name = 'ok';Person.prototype.age = 24;Person.prototype.sayName = function()&#123;console.log(this.name);&#125;;const p1 = new Person();p1.sayName();//24 上面的写法过于繁琐，因此有一种简单写法： 1234567891011function Person()&#123;&#125;Person.prototype =&#123; name:'ok', age:24, sayName:function()&#123; console.log(this.name) &#125;&#125;const p1 = new Person();p1.sayName();//24 将Person.prototype 指向一个新的对象，相当于切断了Person.prototype与真正原型之间的联系,因此需要重新指定构造函数 12345678910111213141516p1.constructor === Person;//false//重新指定构造函数function Person()&#123;&#125;Person.prototype =&#123; constructor:Person, name:'ok', age:24, sayName:function()&#123; console.log(this.name) &#125;&#125;;const p = new Person('ok',23);p.constructor === Person;//true 使用原型模式存在两个问题：第一个是由于没有为构造函数传递初始值，因此所有的实例都将取得一样的默认值，第二个也是最严重的问题，原型对象是共享的。 1234567891011121314151617181920function Person()&#123; &#125;;Person.prototype =&#123; constructor:Person, name:'ok', age:24, skills:['HTML','css','js'], sayName:function()&#123; console.log(this.name) &#125;&#125;;const p1 = new Person();const p2 = new Person();p1.skills;//['HTML','css','js']p2.skills;//['HTML','css','js']p1.skills.push('php');p1.skills;//['HTML','css','js','php'];p2.skills;//['HTML','css','js','php']//WTF 由于原型对象共享的特性，某个实例的修改会影响所有的实例属性。 构造模式与原型模式的组合模式 鉴于构造模式和原型模式都有各自的优缺点，将两者组合起来就可以集两者之长。 12345678910function Person(name,age)&#123; this.name = name; this.age = age;&#125;;Person.prototype =&#123; constructor:Person, sayName:function()&#123; console.log(this.name) &#125;&#125; 这种模式创建的对象，每个实例即拥有自己的属性，又拥有共享的方法，因此，这种模式是最常见的模式。","categories":[{"name":"JavaScript深入系列","slug":"JavaScript深入系列","permalink":"http://iaminvoker.com/categories/JavaScript深入系列/"}],"tags":[{"name":"JavaScript深入系列","slug":"JavaScript深入系列","permalink":"http://iaminvoker.com/tags/JavaScript深入系列/"}]},{"title":"原型与原型链","slug":"2018-02-09-原型与原型链","date":"2018-02-09T05:37:08.000Z","updated":"2018-12-17T11:06:48.008Z","comments":true,"path":"2018/02/09/2018-02-09-原型与原型链/","link":"","permalink":"http://iaminvoker.com/2018/02/09/2018-02-09-原型与原型链/","excerpt":"","text":"[TOC] 构造函数与 prototype任何函数都有 prototype，但一般只讨论构造函数的 prototype。 123456function Person(name, age) &#123; this.name = name; this.age = age;&#125;const p = new Person(\"ok\", 23);Person.prototype; //&#123;constructor:Person&#125; 函数的 prototype 指向这个函数创建的实例对象的原型，也就是 p 的原型。 可以这样理解对象的原型：每个 JavaScript 对象(null 除外)在创建时，都会有一个和它关联的对象，这个对象就是原型，新建的对象可以从原型”继承”属性。 __proto__每个对象(null 除外)都有一个 __proto__ 属性指向这个对象的原型。 函数通过 prototype 表示实例的原型，实例对象通过__proto__ 表示对象的原型。这是个非标准属性，只能在谷歌或者火狐下访问。 1p.__proto__ === Person.prototype; //true constructor构造函数可以通过 prototype 指向原型，原型也可以通过 constructor 指向构造函数，每个原型都有一个 constructor 属性指向关联的构造函数。 1Person.prototype.constructor === Person; //true 通过上面的关系图，可以得出： 构造函数的 prototype 指向原型对象，原型对象的 constructor 属性指向构造函数，而实例对象的__proto__ 指向实例对象的原型。实例在查找属性时，首先从自身开始检索，当自身没有查找到该属性时，就会向原型上搜索。 但是当对象的原型上也没有查找到该属性时，就会去查找原型的原型。 原型的原型记住一点，实例的__proto__ 指向构造函数的 prototype，而构造函数的 prototype 本身也是个(由 Object 构造函数生成的)实例对象，那么这个对象的 __proto__ 就应该指向 Object 的 prototype。 那么 Object.prototype 的原型呢？是 null。null 表示没有对象，它是原型链的终点。 1Object.prototype.__proto__ === null; //true 如上，普通的构造函数遵循这样的原型链图，那么内置的构造函数，如 Array、String 呢？ 拿 Array 举个栗子 Array 就类似于自己写的构造函数，那么它的 prototype 属性就是一个原型对象(普通对象)，实例的__proto__指向构造它的构造函数的原型属性。也就是上图的Array.prototype.__proto__===Object.prototype,其他的内置对象和这里类似。 在 JavaScript 中，有一个特殊的”对象”——函数(Function)，函数既然是一种特殊的对象，那么它应该也遵循这条链。 ​ 到这里原型链看似就很清楚了，但还有一个问题，函数是可以通过 new Function()构建的，这就意味着 像 Array、Object 这类构造函数都是(意淫的)通过 new Function()生成的。那么再套用那句话，实例的__proto__ 指向构造它的构造函数的原型对象。 看了上图，一脸懵逼，Function.prototype 是 Object 实例化的，Object 又是 Function 实例化的，这就产生了”先有鸡还是先有蛋的”经典问题。哲学！ 对于这个问题，网上大佬有各种理解，我个人比较倾向于的是： 这些内置对象是在 JavaScript 内部本身就存在的，并不存在这种构造生成的过程，但是为了遵循 JavaScript 的基于原型链的面向对象的思想，才有了这么一个意淫出来的构造过程。因此，才有了这个更匪夷所思的结果。 因为 Function 本身也是构造函数，也是 new Function()出来的啊(手动滑稽)。 当然，还有一种说法，看起来也挺合理的。 天地初开，一片虚空，只有一个 null null 很无聊，就创造出了 Object.prototype，Object.prototype 更无聊，就造出来了 Function.prototype Function.prototype 很牛叉，就给 Object.prototype 找了个伴儿，叫 Object，也给自己找了个伴儿，叫 Function 然后它们这一家子就创造了万物。。。 通过以上的胡扯，可以看出，JavaScript 的原型链的设计正如刺客信条一样——「Nothing is true,every is permitted.（万物皆虚，万事皆允）」。 仔细去理解这些设计，又觉得如此的哲学。","categories":[{"name":"JavaScript深入系列","slug":"JavaScript深入系列","permalink":"http://iaminvoker.com/categories/JavaScript深入系列/"}],"tags":[{"name":"JavaScript深入系列","slug":"JavaScript深入系列","permalink":"http://iaminvoker.com/tags/JavaScript深入系列/"}]},{"title":"继承","slug":"2018-02-09-继承","date":"2018-02-09T05:37:08.000Z","updated":"2018-12-17T11:02:47.178Z","comments":true,"path":"2018/02/09/2018-02-09-继承/","link":"","permalink":"http://iaminvoker.com/2018/02/09/2018-02-09-继承/","excerpt":"","text":"[TOC] 继承时面向对象编程中一个很重要的概念，虽然在 ES6 中有了 class 和 extends ,但它们实际上只是一种语法糖而已。 原型链继承在构建一个”类”时，这个类实际上是通过原型链继承了 Object 的方法，同理，实现继承也主要是依靠原型链。 12345678910111213141516171819202122function SuperMan() &#123; this.name = \"zeus\";&#125;SuperMan.prototype = &#123; getName: function() &#123; return this.name; &#125;,&#125;;function SubMan(name) &#123; this.type = \"sub\"; this.name = name;&#125;SubMan.prototype = new SuperMan();SubMan.prototype.getType = function() &#123; return this.type;&#125;;const man = new SubMan(\"luna\");man.getName(); //'luna'man.getType(); //'sub' 基于这条原型链，子类就可以继承父类的属性和方法，同时也可以重写父类的属性和方法。 当然，因为父类同样也继承自 Object，因此，实际上，子类也可以通过原型链访问到 Object 的方法，原型链往上延伸了。 12345678910111213man instanceof SubMan;//trueman instanceof SuperMan;//trueman instanceof Object;//trueSubMan.prototype.isPrototypeOf(man);//trueSuperMan.prototype.isPrototypeOf(man);//trueObject.prototype.isPrototypeOf(man);//true 根据上面的原型链，假如我们重写了父类的方法，那么子类访问这个方法时将会访问的是这个重写后的方法，但父类仍然会访问原来的方法，因为我们重写一个方法或者属性时，实际上是在子类的原型对象上添加了这个方法或者属性，但父类的属性和方法并没有受到影响。 需要注意的一点是，为子类定义新的方法或者重写父类方法必须放在指定子类原型之后，否则无法访问。 原型链继承很强大，但存在一个致命的问题，这个问题对象一节中说道，就是共享属性，子类对父类引用类型的修改将会共享给所有的子类。 这种方式存在的第二个问题就是子类无法向父类的构造函数传递参数，因此，很少直接使用原型链继承。 经典继承在 JavaScript 中有两个方法 call 和 apply 可以改变函数 this 的指向，使用这个特性就可以在实例化子类时借用父类的构造函数。 12345678910111213function SuperMan(name) &#123; this.skills = [\"q\", \"w\", \"e\", \"r\"]; this.name = name;&#125;function SubMan(name) &#123; SuperMan.call(this, name);&#125;const man1 = new SubMan(\"yi\");man1.skills.push(\"d\");man1.skills; //qwerd;const man2 = new SubMan(\"ath\");man2.skills; //qwer 使用这种方式，既解决了不能像父类传参的问题，也解决了共享属性的问题，但这种方式不能使用原型链的优势，所有的方法都必须定义在构造函数中。因此，这种方法也很少单独使用。 组合继承扬长避短，组合原型链继承和经典继承的优势，形成的继承方案成为了一种最常用的继承方式。 12345678910111213141516171819202122function SuperMan(name) &#123; this.name = name; this.skills = [\"q\", \"w\", \"e\"];&#125;SuperMan.prototype = &#123; getName: function() &#123; return this.name; &#125;,&#125;;function SubMan(name, age) &#123; SuperMan.call(this, name); //继承属性 this.age = age;&#125;//继承方法//第一次调用父类构造函数SubMan.prototype = new SuperMan();//第二次调用父类构造函数const man = new SubMan(\"yi\", 23);man.getName(); //'yi'man.age; //23man.skills; //qwe 但，这种继承方式存在一个问题，无论什么情况下，都会调用两次父类的构造函数。第一次调用父类构造函数时 SubMan 的原型对象会获得 name 和 skills 两个属性，第二次调用父类的构造函数时，SubMan 的实例又会获得这两个属性。 原型式继承12345function object(o) &#123; function F() &#123;&#125; F.prototype = o; return F;&#125; 静静的看着这段代码不说话。 在 ES5 中，规范化了原型式继承，新增了 Object.create()方法。这个方法的第一个参数用于新生成的对象的原型，第二个可选参数是新对象的额外属性描述符。 寄生组合式继承为了解决组合继承的问题，提出了寄生组合式继承 123456789101112131415161718192021222324252627282930function SuperMan(name) &#123; this.name = name;&#125;SuperMan.prototype.getName = function() &#123; return this.name;&#125;;function SubMan(name, age) &#123; SuperMan.call(this, name); this.age = age;&#125;function object(o) &#123; function F() &#123;&#125; F.prototype = o; return new F();&#125;function inheritPrototype(subType, superType) &#123; var prototype = object(superType.prototype); prototype.constructor = subType; subType.prototype = prototype;&#125;inheritPrototype(SubMan, SuperMan);SubMan.prototype.getAge = function() &#123; return this.age;&#125;;var man = new SubMan(\"yi\", 26);//等同于//SubMan.prototype = Object.create(SuperMan.prototype) 采用寄生组合式继承的原型链 ES6 中的 extends 实际是一种语法糖，我们在使用 babel 转换的时候，实际是转换为了这种继承方式。 123456789101112//es6class Person &#123; constructor() &#123;&#125;&#125;class Man extends Person &#123; constructor() &#123; super(); &#125;&#125;const m = new Man(); babel 的转移 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566\"use strict\";function _possibleConstructorReturn(self, call) &#123; if (!self) &#123; throw new ReferenceError( \"this hasn't been initialised - super() hasn't been called\", ); &#125; return call &amp;&amp; (typeof call === \"object\" || typeof call === \"function\") ? call : self;&#125;function _inherits(subClass, superClass) &#123; //超类必须是一个函数或者null if (typeof superClass !== \"function\" &amp;&amp; superClass !== null) &#123; throw new TypeError( \"Super expression must either be null or a function, not \" + typeof superClass, ); &#125; //原型式继承 subClass.prototype = Object.create(superClass &amp;&amp; superClass.prototype, &#123; //修正constructor指向问题 constructor: &#123; value: subClass, enumerable: false, writable: true, configurable: true, &#125;, &#125;); //将子类的__proto__指向父类的原型对象 if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : (subClass.__proto__ = superClass);&#125;function _classCallCheck(instance, Constructor) &#123; if (!(instance instanceof Constructor)) &#123; throw new TypeError(\"Cannot call a class as a function\"); &#125;&#125;var Person = function Person() &#123; //构造函数不能被当做普通函数调用 _classCallCheck(this, Person);&#125;;var Man = (function(_Person) &#123; //继承 _inherits(Man, _Person); function Man() &#123; _classCallCheck(this, Man); //相当于SuperType.call(this),调用父类的构造函数 return _possibleConstructorReturn( this, (Man.__proto__ || Object.getPrototypeOf(Man)).call(this), ); &#125; return Man;&#125;)(Person);var m = new Man();","categories":[{"name":"JavaScript深入系列","slug":"JavaScript深入系列","permalink":"http://iaminvoker.com/categories/JavaScript深入系列/"}],"tags":[{"name":"JavaScript深入系列","slug":"JavaScript深入系列","permalink":"http://iaminvoker.com/tags/JavaScript深入系列/"}]},{"title":"基本概念","slug":"2018-01-30-基本概念","date":"2018-01-30T01:59:20.000Z","updated":"2018-05-03T09:32:23.659Z","comments":true,"path":"2018/01/30/2018-01-30-基本概念/","link":"","permalink":"http://iaminvoker.com/2018/01/30/2018-01-30-基本概念/","excerpt":"","text":"[TOC] 语法注意点JavaScript严格区分大小写； 为了与ECMAScript内置函数保持一致，也为了最佳实践，JavaScript应该使用驼峰大小写。 未经声明的变量在严格模式下会抛出ReferenceError错误。 数据类型JavaScript有五种简单数据类型(ES6 新增了一种Symbol)： Undefined、Null、Boolean、Number、String 一种复杂数据类型： Object 可以使用typeof判断某些简单数据类型：Undefined、Boolean、Number、String 、（Symbol）。 但是typeof判断null会返回’object’ 1typeof null ;//'object' 这是因为在 JavaScript 最初的实现中，JavaScript 中的值是由一个表示类型的标签和实际数据值表示的。对象的类型标签是 0。由于 null 代表的是空指针（大多数平台下值为 0x00），因此，null的类型标签也成为了 0，typeof null就错误的返回了”object&quot; Undefined类型只有一个值：undefined。未初始化的变量值为undefined。使用typeof 检测一个未声明的变量也会返回undefined。但事实上，未声明的变量也只能执行这一个操作。 Null类型也只有一个值：null。它表示一个空对象指针。并且 1undefined == null;// true 因为undefined实际上派生自null，所以他们在使用相等操作符时会返回true 传递参数12345678910111213141516function changeStuff(a, b, c)&#123; a = a * 10; b.item = \"changed\"; c = &#123;item: \"changed\"&#125;;&#125;var num = 10;var obj1 = &#123;item: \"unchanged\"&#125;;var obj2 = &#123;item: \"unchanged\"&#125;;changeStuff(num, obj1, obj2);console.log(num);//10console.log(obj1.item);//'changed'console.log(obj2.item);//'unchanged' JavaScript函数传参都是按值传递，对于基本类型，直接将实参复制给形参，但对于引用类型，复制的是表明对象在堆内存中的内存地址，因此，在函数内部对引用类型的修改也会反映在外部。 执行环境与作用域链全局执行环境默认为window对象，每个函数都有自己的执行环境，当执行到某个函数时，函数的执行环境会被推入一个环境栈，在函数执行完后再将其环境弹出，把控制权交给之前的环境。 在代码执行时，会创建一个作用域链，作用域链的前端始终是当前函数执行环境的变量对象，全局执行环境始终是作用域链的最后一个对象。 JavaScript的标识符搜索就是沿着作用域链查找直到最后一个对象。 垃圾收集JavaScript具有自动垃圾收集机制，一般有两个策略： 标记清除 当变量进入环境时标记上”进入环境”，当变量离开环境时标记上”离开环境”。标记上”离开环境”的变量将不能再访问，它们会在垃圾回收器执行内存清除工作时，销毁这些变量，回收它们所占的内存。 引用计数 当一个变量被引用时，将它的引用次数+1，当引用这个变量的变量有重新取得一个值，则将这个变量的引用次数-1，当它的引用次数为0时，将被垃圾回收器回收。使用这种方式存在循环引用的问题，这样，它们将永远不会被释放。","categories":[{"name":"JavaScript深入系列","slug":"JavaScript深入系列","permalink":"http://iaminvoker.com/categories/JavaScript深入系列/"}],"tags":[{"name":"JavaScript深入学习","slug":"JavaScript深入学习","permalink":"http://iaminvoker.com/tags/JavaScript深入学习/"}]},{"title":"JavaScript历史","slug":"2018-01-30-JavaScript历史","date":"2018-01-30T01:48:18.000Z","updated":"2018-05-03T09:32:23.658Z","comments":true,"path":"2018/01/30/2018-01-30-JavaScript历史/","link":"","permalink":"http://iaminvoker.com/2018/01/30/2018-01-30-JavaScript历史/","excerpt":"","text":"JavaScript的作者是当时就职与Netscape公司的Brendan Eich，最早名为Livescript，在Livescript发布之际，为了蹭一波Java的热度临时将名字改为JavaScript。JavaScript1.0的发布取得了巨大成功，此时微软也在其IE浏览器中加入了JScript的JavaScript实现，此时市面上存在了三个不同的JavaScript实现，因此JavaScript的标准化问题被提上了日程。随后，以JavaScript1.1为蓝本的建议呗提交给ECMA组织，他们制定了名为ECMAScript的新脚本语音标准，这也是现在我们经常说的ES5、ES6中的’ES’来源.从此，浏览器开发商就开始致力于将ECMAScript作为各自JavaScript实现的基础。我们平时所说的JavaScript通常和ECMAScript是一个东西，但事实上，JavaScript的含义被ECMAScript定义的多得多，完整的JavaScript应该包含三部分：核心(ECMAScript)、文档对象模型(DOM)、浏览器对象模型(BOM)。 DOMDOM是一个针对XML但经过扩展用于HTML的API，它把整个页面映射为一个多层级的节点结构。 BOMBOM是一个用于访问和操作浏览器窗口的浏览器对象模型 总的来说，JavaScript是一种为了与网页交互设计的语言，它包含了三个部分： ECMAScript，由ECMA-262定义，它包含了语言的核心功能 DOM，提供操作网页内容的方法和接口 BOM，提供了与浏览器交互的接口","categories":[],"tags":[{"name":"JavaScript深入学习","slug":"JavaScript深入学习","permalink":"http://iaminvoker.com/tags/JavaScript深入学习/"}]},{"title":"module.exports和exports","slug":"2017-11-16-module-exports和exports","date":"2017-11-16T12:24:30.000Z","updated":"2018-05-03T09:32:23.657Z","comments":true,"path":"2017/11/16/2017-11-16-module-exports和exports/","link":"","permalink":"http://iaminvoker.com/2017/11/16/2017-11-16-module-exports和exports/","excerpt":"1234567891011var name = 'rainbow';exports.name = name;exports.sayName = function()&#123; console.log(name);&#125;// 给 exports 赋值相当于给 module.exports 这个空对象添加了两个属性，相当于：var name = 'rainbow';module.exports.name = name;module.exports.sayName = function()&#123; console.log(name);&#125;","text":"1234567891011var name = 'rainbow';exports.name = name;exports.sayName = function()&#123; console.log(name);&#125;// 给 exports 赋值相当于给 module.exports 这个空对象添加了两个属性，相当于：var name = 'rainbow';module.exports.name = name;module.exports.sayName = function()&#123; console.log(name);&#125; 在使用require时，得到的始终是module.exports（也可以说导出的始终是module.exports），而module.exports=exports exports.xxx相当于给exports挂属性，也就是对module.exports挂属性，也就是对require得到的模块挂属性，而使用module.exports =xxx 就是直接让这个模块等于xxx","categories":[],"tags":[]}]}